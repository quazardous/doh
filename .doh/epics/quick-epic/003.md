---
id: 003
title: Build dependency analysis for inserting tasks into open epics
status: pending
created: 2025-08-31T15:00:00Z
priority: high
estimate: 10 hours
epic: quick-epic
depends_on: [001, 002]
---

# Task 003: Build dependency analysis for inserting tasks into open epics

## Overview

Implement logic to analyze existing task dependencies within an epic and determine the optimal insertion point for new quick tasks. This ensures new tasks integrate properly with existing workflow without breaking dependency chains.

## Requirements

### Functional Requirements

#### Dependency Chain Analysis
- Read all task files within selected epic
- Parse `depends_on` fields to build dependency graph
- Identify tasks that could logically depend on new task
- Detect circular dependency risks

#### Insertion Logic
- Determine appropriate task number sequence (next available)
- Identify tasks that should depend on the new task
- Calculate which existing tasks need `depends_on` updates
- Present dependency modification plan to user for approval

#### Task Integration
- Insert new task with proper numbering (e.g., 004, 005)
- Update affected tasks' `depends_on` fields
- Maintain dependency chain integrity
- Preserve existing epic structure

#### User Confirmation
- Show exactly which files will be modified
- Display before/after dependency changes
- Allow user to approve/reject dependency modifications
- Provide option to add task without dependencies

### Technical Requirements

#### Graph Processing
- Build in-memory dependency graph from task files
- Detect and report circular dependencies
- Calculate dependency depth and complexity
- Efficient traversal algorithms

#### File Operations
- Parse task frontmatter using existing frontmatter.sh
- Safely update multiple task files atomically
- Backup original files before modifications
- Rollback capability on failure

#### Integration Points
- Work with both numbered tasks (001, 002) and maintenance tasks
- Handle mixed dependency patterns
- Support various frontmatter formats

## Implementation Details

### Algorithm Approach
1. **Discovery**: Scan epic directory for task files
2. **Parsing**: Extract dependencies from each task
3. **Graph Building**: Create dependency relationship map
4. **Analysis**: Determine logical insertion point
5. **Planning**: Calculate required dependency updates
6. **Confirmation**: Present plan to user
7. **Execution**: Apply changes atomically

### File Structure
```bash
.claude/scripts/doh/lib/
├── dependency-analyzer.sh    # Core dependency logic
├── task-integration.sh      # Task insertion and updates
└── graph-utils.sh           # Graph traversal utilities
```

### Key Functions
- `build_dependency_graph(epic_dir)` - Create dependency map
- `find_insertion_point(graph, new_task_type)` - Determine placement
- `calculate_updates(graph, insertion_point)` - Plan dependency changes
- `apply_task_integration(epic_dir, updates)` - Execute changes
- `validate_dependencies(graph)` - Check for circular dependencies

### Dependency Update Logic
```bash
# Example: New authentication task should be inserted
# Current: 001-setup -> 002-database -> 003-frontend
# New: 002-auth (needs database, frontend needs auth)
# Result: 001-setup -> 002-database -> 003-auth -> 004-frontend
```

### Dependencies
- Task 001: Need matching algorithm to identify target epic
- Task 002: Need user selection to trigger analysis
- Existing frontmatter.sh library for file parsing
- Task.sh library for task file operations

## Testing Strategy

### Dependency Scenarios
1. **Linear Chain**: Simple sequential dependencies
2. **Branching**: Multiple tasks depend on same parent
3. **Complex Web**: Multiple interdependencies
4. **No Dependencies**: Tasks without relationships
5. **Mixed Types**: Regular + maintenance tasks

### Integration Testing  
- Test with real epic structures from existing projects
- Validate with various frontmatter formats
- Ensure no corruption of existing task files
- Test rollback on failure scenarios

### Edge Cases
- Empty epic (first task)
- Single existing task
- All tasks completed
- Circular dependency detection
- Malformed task files

## Acceptance Criteria

- [ ] Dependency graph correctly represents task relationships
- [ ] Insertion point logic produces sensible placement
- [ ] User sees clear plan of what will be modified
- [ ] Atomic updates ensure no partial state corruption
- [ ] Circular dependency detection prevents invalid states
- [ ] Integration preserves existing epic structure
- [ ] Rollback works correctly on failures
- [ ] Performance acceptable for epics with 20+ tasks

## Definition of Done

- Dependency analysis algorithm implemented and tested
- Task integration logic handles various epic structures  
- User confirmation workflow provides clear information
- Atomic file operations prevent corruption
- Integration with existing DOH libraries successful
- All test scenarios pass including edge cases