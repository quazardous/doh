# T064 - Enhance /dd:commit with --split Flag for Semantic Commit Splitting ğŸ“¦

**Project**: DOH-DEV Internal
**Status**: COMPLETED  
**Priority**: MEDIUM - Development Experience Enhancement  
**Dependencies**: None (standalone improvement)  
**Epic**: E075 DOH-DEV Internal System - Phase 1  
**Tags**: `#features` `#pipeline` `#commits` `#automation`  
**Estimated Effort**: 3-4 hours  
**Created**: 2025-08-28  
**Updated**: 2025-08-28 (Default behavior: commit all modified files)  
**Proposed Version**: 1.4.0

## ğŸ“‹ Description

Enhance the `/doh-sys:commit` command with an intelligent `--split` flag that automatically analyzes large staging areas
and creates semantically meaningful multiple commits. The system should prioritize heavy epic/TODO updates first, then
iteratively process remaining changes to create a logical commit sequence.

## ğŸ¯ Problem Statement

Currently, `/doh-sys:commit` creates single monolithic commits even when staging contains multiple logical units of
work:

**Current Limitations**:

- Large staging areas result in unfocused commits
- Mixed epic updates, documentation changes, and code modifications in single commit
- Poor commit history granularity reduces traceability
- No automatic semantic grouping of related changes
- Modified files often left uncommitted after partial staging

**Target Enhancement**:

- Intelligent semantic analysis of ALL modified files (not just staged)
- Automatic splitting into logical, focused commits
- Priority-based commit ordering (epic/TODO updates first)
- Clean, granular commit history that tells a story
- **COMPLETE COVERAGE**: Ensure ALL modified files are committed (default behavior)
- Optional `--staged-focused` flag for users who want explicit control

## Core Functionality

### 1. Semantic Change Analysis

Analyze staged files and categorize changes by logical grouping:

#### Change Categories (Priority Order)

1. **Epic/TODO Updates**: `todo/*.md`, `NEXT.md`, epic documentation changes
2. **DOH System Changes**: `.claude/doh/` modifications, templates, scripts
3. **Documentation Updates**: `README.md`, `WORKFLOW.md`, `DEVELOPMENT.md`
4. **Core Implementation**: Source code, main functionality changes
5. **Configuration Changes**: Config files, package.json, build scripts
6. **Test Updates**: Test files, test configuration
7. **Minor/Cosmetic**: Formatting, typos, small adjustments

### 2. Intelligent Commit Splitting Strategy

```text
Strategy: Heavy Epic/TODO Updates First â†’ Iterative Processing â†’ Complete Coverage

DEFAULT BEHAVIOR: Commit ALL modified files (staged and unstaged)
- Start with staged files for priority categorization
- Auto-stage and include all remaining modified files in appropriate commits
- Ensure no modified files are left uncommitted

FOCUSED MODE (--staged-focused flag): Only process staged files
- Ignore unstaged/untracked files completely
- User explicitly controls what gets committed

Phase 1: Epic & Planning Updates
â”œâ”€â”€ Commit 1: "feat: Complete T### epic and task updates"
â”‚   â”œâ”€â”€ todo/T***.md status changes (staged + unstaged)
â”‚   â”œâ”€â”€ todo/NEXT.md memory updates
â”‚   â””â”€â”€ Epic documentation updates

Phase 2: System & Infrastructure
â”œâ”€â”€ Commit 2: "feat: Enhance DOH system [specific improvement]"
â”‚   â”œâ”€â”€ .claude/doh/ script updates (all modified)
â”‚   â”œâ”€â”€ Template modifications
â”‚   â””â”€â”€ DOH infrastructure changes

Phase 3: Documentation & Communication
â”œâ”€â”€ Commit 3: "docs: Update project documentation"
â”‚   â”œâ”€â”€ README.md changes (all versions)
â”‚   â”œâ”€â”€ WORKFLOW.md updates
â”‚   â””â”€â”€ DEVELOPMENT.md improvements

Phase 4: Core Implementation (if any)
â”œâ”€â”€ Commit 4: "feat: Implement [specific feature]"
â”‚   â”œâ”€â”€ Source code changes (all modified files)
â”‚   â””â”€â”€ Related functionality

Phase N: Remaining Changes
â””â”€â”€ Commit N: "[appropriate prefix]: [remaining changes description]"
    â””â”€â”€ Any files not categorized above
```

### 3. Smart Commit Message Generation

Generate contextually appropriate commit messages based on change analysis:

#### Message Templates by Category

- **Epic/TODO**: `feat: Complete T### {task_title} and update project roadmap`
- **DOH System**: `feat: Enhance DOH {component} with {improvement}`
- **Documentation**: `docs: Update {doc_type} with {improvement_area}`
- **Implementation**: `feat: Implement {feature_name} for {purpose}`
- **Configuration**: `chore: Update {config_type} configuration`
- **Testing**: `test: Add/update tests for {feature_area}`
- **Fixes**: `fix: Resolve {issue_description}`

## Tasks

### Phase 1: Change Analysis Engine (1.5h)

- [ ] **Design semantic categorization** algorithm for staged files
- [ ] **Implement file pattern recognition** for DOH project structure
- [ ] **Create change impact analysis** to group related modifications
- [ ] **Add content analysis** for commit message context extraction

### Phase 2: Splitting Logic Implementation (1.5h)

- [ ] **Implement priority-based grouping** starting with epic/TODO updates
- [ ] **Create iterative processing** for remaining change categories
- [ ] **Add dependency detection** between related changes
- [ ] **Build commit sequence optimization** for logical ordering

### Phase 3: Commit Message Intelligence (1h)

- [ ] **Implement context-aware message generation** based on change analysis
- [ ] **Add template system** for different commit categories
- [ ] **Create smart prefix selection** (feat/docs/fix/chore) based on content
- [ ] **Add task ID detection** and integration into commit messages

### Phase 4: User Experience & Safety (30min)

- [ ] **Add preview mode** showing planned commit sequence
- [ ] **Implement confirmation flow** before executing splits
- [ ] **Create rollback capability** if splitting goes wrong
- [ ] **Add override options** for manual commit message specification

## Technical Implementation

### Command Usage

```bash
# DEFAULT: Commit ALL modified files with semantic splitting
/doh-sys:commit --split
# â†’ Analyzes all modified files (staged + unstaged)
# â†’ Uses staged files to determine priority
# â†’ Creates multiple commits covering ALL changes
# â†’ Leaves working directory completely clean

# FOCUSED MODE: Only commit what's explicitly staged
/doh-sys:commit --split --staged-focused
# â†’ Only processes files you've staged with git add
# â†’ Ignores all unstaged and untracked files
# â†’ Gives you explicit control over what gets committed

# Preview split without executing
/doh-sys:commit --split --dry-run

# Split with manual review of each commit
/doh-sys:commit --split --interactive

# Focused mode with interaction
/doh-sys:commit --split --staged-focused --interactive

# Combine with existing options
/doh-sys:commit --split --no-lint --staged-focused
```

### Smart Staging Analysis Algorithm

```bash
analyze_workspace_changes() {
    # Phase 1: Analyze current workspace state
    staged_files=$(git diff --cached --name-only)
    unstaged_files=$(git diff --name-only)
    untracked_files=$(git ls-files --others --exclude-standard)

    echo "ğŸ” Workspace Analysis:"
    echo "â”œâ”€â”€ Staged files: $(echo "$staged_files" | wc -l)"
    echo "â”œâ”€â”€ Modified unstaged: $(echo "$unstaged_files" | wc -l)"
    echo "â””â”€â”€ Untracked files: $(echo "$untracked_files" | wc -l)"

    if [[ "$STAGED_FOCUSED" == "true" ]]; then
        echo "ğŸ¯ Mode: Staged-focused (only committing staged files)"
    else
        echo "ğŸ“¦ Mode: Complete coverage (will commit ALL modified files)"
    fi

    # Phase 2: Process ALL files based on mode
    if [[ "$STAGED_FOCUSED" == "true" ]]; then
        # FOCUSED MODE: Only process staged files
        if [[ -n "$staged_files" ]]; then
            echo "ğŸ“‹ Processing staged files only..."
            categorize_and_split_files "$staged_files"
        else
            echo "âŒ No staged files found. Use 'git add' to stage files first."
            exit 1
        fi
    else
        # DEFAULT MODE: Process ALL modified files
        all_modified_files=$(combine_all_modified "$staged_files" "$unstaged_files")

        if [[ -n "$all_modified_files" ]]; then
            echo "ğŸ“‹ Processing ALL modified files for complete coverage..."
            echo "ğŸ¯ Using staged files to determine priority..."
            categorize_and_split_all_files "$all_modified_files" "$staged_files"
        else
            echo "âœ… No modified files to commit."
            exit 0
        fi
    fi
}

categorize_and_split_all_files() {
    local all_files=$1
    local priority_files=$2  # Originally staged files for priority hints

    # Smart categorization using priority files as hints
    echo "ğŸ” Analyzing files for semantic grouping..."

    # Categorize ALL modified files
    epic_files=$(echo "$all_files" | grep -E "todo/.*\.md|NEXT\.md")
    doh_system_files=$(echo "$all_files" | grep -E "\.claude/doh/|\.claude/commands/")
    docs_files=$(echo "$all_files" | grep -E "README\.md|WORKFLOW\.md|DEVELOPMENT\.md|CHANGELOG\.md")
    config_files=$(echo "$all_files" | grep -E "package\.json|\.config\.|Makefile")
    test_files=$(echo "$all_files" | grep -E "test/|spec/|\.test\.|\.spec\.")

    # Use staged files to determine commit priority
    priority_epic=$(echo "$priority_files" | grep -E "todo/.*\.md|NEXT\.md")
    priority_system=$(echo "$priority_files" | grep -E "\.claude/")

    # Create comprehensive split plan
    create_complete_split_plan "$epic_files" "$doh_system_files" "$docs_files" "$config_files" "$test_files"
}

categorize_and_split_files() {
    # For staged-focused mode (existing behavior)
    local staged_files=$1

    # Smart categorization of staged files only
    epic_files=$(echo "$staged_files" | grep -E "todo/.*\.md|NEXT\.md")
    doh_system_files=$(echo "$staged_files" | grep -E "\.claude/doh/|\.claude/commands/")
    docs_files=$(echo "$staged_files" | grep -E "README\.md|WORKFLOW\.md|DEVELOPMENT\.md|CHANGELOG\.md")
    runtime_files=$(echo "$staged_files" | grep -E "\.claude/commands/doh/")

    # Create split plan from staged files only
    create_staged_split_plan "$epic_files" "$doh_system_files" "$docs_files" "$runtime_files"
}

detect_obvious_semantic_matches() {
    local unstaged_files=$1
    local obvious_matches=""

    # Rule 1: If todo/NEXT.md is staged and todo/T###.md is unstaged â†’ obvious match
    if git diff --cached --name-only | grep -q "todo/NEXT.md"; then
        new_task_files=$(echo "$unstaged_files" | grep -E "todo/T[0-9]+\.md$")
        obvious_matches="$obvious_matches\n$new_task_files"
    fi

    # Rule 2: If .claude/commands/doh-sys/commit.md is staged and .claude/commands/doh/*.md modified â†’ potential match
    if git diff --cached --name-only | grep -q "\.claude/commands/doh-sys/"; then
        doh_runtime_commands=$(echo "$unstaged_files" | grep -E "\.claude/commands/doh/.*\.md$")
        # Only auto-add if it's clear enhancement (e.g., same feature being added to both systems)
        obvious_matches="$obvious_matches\n$doh_runtime_commands"
    fi

    # Rule 3: If epic/task documentation is staged and related implementation exists
    staged_tasks=$(git diff --cached --name-only | grep -E "todo/T[0-9]+\.md$" | sed 's/todo\/T\([0-9]*\)\.md/T\1/')
    for task in $staged_tasks; do
        # Look for related implementation files
        related_impl=$(echo "$unstaged_files" | grep -E "\.(md|sh|js)$" | xargs grep -l "$task" 2>/dev/null)
        if [[ -n "$related_impl" ]]; then
            obvious_matches="$obvious_matches\n$related_impl"
        fi
    done

    # Rule 4: Documentation sets - if README.md staged and DEVELOPMENT.md/WORKFLOW.md modified
    if git diff --cached --name-only | grep -q -E "(README|DEVELOPMENT|WORKFLOW)\.md"; then
        doc_set=$(echo "$unstaged_files" | grep -E "(README|DEVELOPMENT|WORKFLOW|CHANGELOG)\.md$")
        obvious_matches="$obvious_matches\n$doc_set"
    fi

    # Clean up and return unique matches
    echo -e "$obvious_matches" | grep -v "^$" | sort -u
}

create_commit_sequence() {
    # Priority order: Epic â†’ System â†’ Docs â†’ Implementation â†’ Misc
    if [[ -n "$epic_files" ]]; then
        plan_epic_commit "$epic_files"
    fi

    if [[ -n "$doh_system_files" ]]; then
        plan_system_commit "$doh_system_files"
    fi

    # Continue iteratively with remaining categories
}
```

### Smart Message Generation

```bash
generate_commit_message() {
    local category=$1
    local files=$2

    case $category in
        "epic")
            local completed_tasks=$(extract_completed_tasks "$files")
            echo "feat: Complete $completed_tasks and update project roadmap"
            ;;
        "doh_system")
            local component=$(detect_doh_component "$files")
            local improvement=$(analyze_system_changes "$files")
            echo "feat: Enhance DOH $component with $improvement"
            ;;
        "documentation")
            local doc_focus=$(analyze_doc_changes "$files")
            echo "docs: Update project documentation - $doc_focus"
            ;;
        *)
            generate_default_message "$category" "$files"
            ;;
    esac
}
```

### Safety & Preview Features

```bash
preview_split_plan() {
    echo "ğŸ” Proposed Commit Split:"
    echo ""

    for i in "${!planned_commits[@]}"; do
        echo "Commit $((i+1)): ${commit_messages[i]}"
        echo "  Files: ${commit_files[i]}"
        echo "  Changes: ${change_summaries[i]}"
        echo ""
    done

    echo "Execute this plan? [Y/n/preview-diff]"
}

execute_split_commits() {
    for i in "${!planned_commits[@]}"; do
        echo "Creating commit $((i+1))/${#planned_commits[@]}: ${commit_messages[i]}"

        # Stage only files for this commit
        git reset HEAD >/dev/null
        git add ${commit_files[i]}

        # Create commit with generated message
        git commit -m "${commit_messages[i]}"

        echo "âœ… Commit $((i+1)) complete"
    done

    # Final verification - ensure no modified files remain
    remaining_modified=$(git diff --name-only)
    if [[ -n "$remaining_modified" && "$STAGED_FOCUSED" != "true" ]]; then
        echo "âš ï¸ Warning: Modified files remain after split sequence"
        echo "This should not happen in default mode. Creating final cleanup commit..."
        git add -A
        git commit -m "chore: Include remaining modified files from split sequence"
    fi

    echo "âœ… Split sequence complete - working directory clean"
}
```

## User Experience Scenarios

### Scenario 1: Complete Coverage (Default Behavior)

```bash
# User has staged some priority files
$ git add todo/T064.md todo/NEXT.md

# DEFAULT: Algorithm commits ALL modified files
$ /doh-sys:commit --split

ğŸ” Workspace Analysis:
â”œâ”€â”€ Staged files: 2
â”œâ”€â”€ Modified unstaged: 15
â””â”€â”€ Untracked files: 3
ğŸ“¦ Mode: Complete coverage (will commit ALL modified files)

ğŸ¯ Using staged files to determine priority...
ğŸ“‹ Processing ALL modified files for complete coverage...

ğŸš€ Executing Split Sequence:
â”œâ”€â”€ âœ… Commit 1/3: feat: Complete T064 commit splitting and update roadmap
â”‚   â””â”€â”€ Files: todo/T064.md, todo/NEXT.md, todo/T063.md (all TODO updates)
â”œâ”€â”€ âœ… Commit 2/3: feat: Enhance DOH commit pipeline with semantic splitting
â”‚   â””â”€â”€ Files: All .claude/commands/ modifications
â””â”€â”€ âœ… Commit 3/3: docs: Update project documentation
    â””â”€â”€ Files: DEVELOPMENT.md, CLAUDE.md (all doc changes)

âœ… Split sequence complete - working directory clean
ğŸ‰ Created 3 focused commits covering ALL 17 modified files

# Alternative: User wants explicit control
$ /doh-sys:commit --split --staged-focused
ğŸ¯ Mode: Staged-focused (only committing staged files)
# Only commits the 2 explicitly staged files, ignores the other 15
```

### Scenario 2: Large Epic Completion

```bash
$ /doh-sys:commit --split --dry-run

ğŸ” Analysis: 15 files staged across 4 semantic categories

ğŸ“‹ Proposed Commit Sequence:

Commit 1: "feat: Complete T059 AI Task Engine and update project roadmap"
  Files: todo/T059.md, todo/NEXT.md, todo/T061.md
  Changes: Task completion status, memory updates, dependency graph

Commit 2: "feat: Enhance DOH runtime with AI task intelligence system"
  Files: .claude/commands/doh/next.md, .claude/doh/templates/memory_structure.md
  Changes: New /doh:next command, memory architecture templates

Commit 3: "docs: Update DOH runtime documentation with task intelligence"
  Files: .claude/doh/inclaude.md
  Changes: Added task intelligence section, pipeline automation docs

Execute this 3-commit sequence? [Y/n/edit-messages]
```

### Scenario 2: Mixed Development Changes

```bash
$ /doh-sys:commit --split --interactive

ğŸ” Analysis: 8 files staged across 3 semantic categories

Commit 1/3: "feat: Complete T032 build system design"
Files: todo/T032.md, todo/NEXT.md
Execute this commit? [Y/n/edit/skip]: Y
âœ… Commit 1 complete

Commit 2/3: "feat: Implement runtime build process"
Files: .claude/doh/scripts/build-runtime.sh, .claude/doh/scripts/lib/build-utils.sh
Execute this commit? [Y/n/edit/skip]: n

Edit commit message: feat: Add DOH runtime build automation scripts
âœ… Commit 2 complete

Commit 3/3: "docs: Update build documentation"
Files: DEVELOPMENT.md
Execute this commit? [Y/n/edit/skip]: Y
âœ… Commit 3 complete

Split complete! Created 3 focused commits.
```

## Success Criteria

- [ ] **Semantic analysis** correctly categorizes ALL modified files by logical grouping
- [ ] **Epic/TODO priority** - Heavy planning updates always committed first
- [ ] **Intelligent splitting** creates focused, single-purpose commits
- [ ] **Smart messages** generate contextually appropriate commit descriptions
- [ ] **Preview functionality** allows review before execution
- [ ] **Safety features** enable rollback and manual override when needed
- [ ] **Complete coverage by default** - ALL modified files committed (no leftovers)
- [ ] **Staged-focused mode** - Optional flag to only commit staged files
- [ ] **Clean working directory** - After split, no modified files remain (unless --staged-focused)

## Benefits & Impact

- **Cleaner History**: Semantic commits create readable, traceable project timeline
- **Better Traceability**: Each commit focuses on single logical unit of work
- **Epic Completion Clarity**: TODO/epic updates are isolated and clearly marked
- **Automated Intelligence**: Reduces mental overhead of commit organization
- **Development Flow**: Maintains development momentum while improving commit quality

## Integration Points

- **Extends**: Current `/doh-sys:commit` functionality with non-breaking enhancement
- **Integrates with**: `/doh-sys:lint`, `/doh-sys:changelog` pipeline commands
- **Complements**: T059 task intelligence system for epic-aware commit planning
- **Prepares for**: Advanced git workflow automation in future versions

## Implementation Notes

**Backward Compatibility**: `--split` is optional flag - existing behavior unchanged for standard usage.

**Strategy Priority**: Epic/TODO updates first ensures project management changes are committed before implementation
details.

**Content Analysis**: Smart message generation analyzes actual file changes, not just filenames, for accurate commit
descriptions.

**Safety First**: Preview and confirmation modes prevent unwanted automated commits while providing intelligent
defaults.

## Deliverable

Enhanced `/doh-sys:commit` command with `--split` flag that intelligently analyzes staging area and creates semantically
focused multiple commits, prioritizing epic/TODO updates first and iteratively processing remaining changes to produce
clean, traceable commit history that tells the story of development progress.

This enhancement transforms large, unfocused commits into logical sequences that improve project traceability while
maintaining development workflow efficiency through intelligent automation.

---
