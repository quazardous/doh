# T064 - Enhance /doh-sys:commit with --split Flag for Semantic Commit Splitting 📦

**Status**: IN PROGRESS - Algorithm Enhancement  
**Priority**: MEDIUM - Development Experience Enhancement  
**Dependencies**: None (standalone improvement)  
**Epic**: E001 DOH Version 1.4.0 Release - Phase 3  
**Tags**: `#features` `#pipeline` `#commits` `#automation`  
**Estimated Effort**: 3-4 hours  
**Created**: 2025-08-28  
**Updated**: 2025-08-28 (Algorithm refinement needed)  
**Proposed Version**: 1.4.0  

## 📋 Description

Enhance the `/doh-sys:commit` command with an intelligent `--split` flag that automatically analyzes large staging areas and creates semantically meaningful multiple commits. The system should prioritize heavy epic/TODO updates first, then iteratively process remaining changes to create a logical commit sequence.

## 🎯 Problem Statement

Currently, `/doh-sys:commit` creates single monolithic commits even when staging contains multiple logical units of work:

**Current Limitations**:
- Large staging areas result in unfocused commits
- Mixed epic updates, documentation changes, and code modifications in single commit
- Poor commit history granularity reduces traceability
- No automatic semantic grouping of related changes

**Target Enhancement**:
- Intelligent semantic analysis of staged changes
- Automatic splitting into logical, focused commits
- Priority-based commit ordering (epic/TODO updates first)
- Clean, granular commit history that tells a story

## Core Functionality

### 1. Semantic Change Analysis

Analyze staged files and categorize changes by logical grouping:

#### Change Categories (Priority Order)
1. **Epic/TODO Updates**: `todo/*.md`, `NEXT.md`, epic documentation changes
2. **DOH System Changes**: `.claude/doh/` modifications, templates, scripts
3. **Documentation Updates**: `README.md`, `WORKFLOW.md`, `DEVELOPMENT.md`
4. **Core Implementation**: Source code, main functionality changes
5. **Configuration Changes**: Config files, package.json, build scripts
6. **Test Updates**: Test files, test configuration
7. **Minor/Cosmetic**: Formatting, typos, small adjustments

### 2. Intelligent Commit Splitting Strategy

```
Strategy: Heavy Epic/TODO Updates First → Iterative Processing

Phase 1: Epic & Planning Updates
├── Commit 1: "feat: Complete T### epic and task updates"
│   ├── todo/T***.md status changes
│   ├── todo/NEXT.md memory updates
│   └── Epic documentation updates

Phase 2: System & Infrastructure
├── Commit 2: "feat: Enhance DOH system [specific improvement]"
│   ├── .claude/doh/ script updates
│   ├── Template modifications
│   └── DOH infrastructure changes

Phase 3: Documentation & Communication
├── Commit 3: "docs: Update project documentation"
│   ├── README.md changes
│   ├── WORKFLOW.md updates
│   └── DEVELOPMENT.md improvements

Phase 4: Core Implementation (if any)
├── Commit 4: "feat: Implement [specific feature]"
│   ├── Source code changes
│   └── Related functionality

Phase N: Remaining Changes
└── Commit N: "[appropriate prefix]: [remaining changes description]"
```

### 3. Smart Commit Message Generation

Generate contextually appropriate commit messages based on change analysis:

#### Message Templates by Category
- **Epic/TODO**: `feat: Complete T### {task_title} and update project roadmap`
- **DOH System**: `feat: Enhance DOH {component} with {improvement}`
- **Documentation**: `docs: Update {doc_type} with {improvement_area}`
- **Implementation**: `feat: Implement {feature_name} for {purpose}`
- **Configuration**: `chore: Update {config_type} configuration`
- **Testing**: `test: Add/update tests for {feature_area}`
- **Fixes**: `fix: Resolve {issue_description}`

## Tasks

### Phase 1: Change Analysis Engine (1.5h)

- [ ] **Design semantic categorization** algorithm for staged files
- [ ] **Implement file pattern recognition** for DOH project structure
- [ ] **Create change impact analysis** to group related modifications
- [ ] **Add content analysis** for commit message context extraction

### Phase 2: Splitting Logic Implementation (1.5h)

- [ ] **Implement priority-based grouping** starting with epic/TODO updates
- [ ] **Create iterative processing** for remaining change categories
- [ ] **Add dependency detection** between related changes
- [ ] **Build commit sequence optimization** for logical ordering

### Phase 3: Commit Message Intelligence (1h)

- [ ] **Implement context-aware message generation** based on change analysis
- [ ] **Add template system** for different commit categories
- [ ] **Create smart prefix selection** (feat/docs/fix/chore) based on content
- [ ] **Add task ID detection** and integration into commit messages

### Phase 4: User Experience & Safety (30min)

- [ ] **Add preview mode** showing planned commit sequence
- [ ] **Implement confirmation flow** before executing splits
- [ ] **Create rollback capability** if splitting goes wrong
- [ ] **Add override options** for manual commit message specification

## Technical Implementation

### Command Usage

```bash
# Basic semantic splitting (analyzes staged + offers unstaged inclusion)
/doh-sys:commit --split

# Focus only on staged files, ignore unstaged/untracked
/doh-sys:commit --split --staged-focused

# Preview split without executing
/doh-sys:commit --split --dry-run

# Split with manual review of each commit
/doh-sys:commit --split --interactive

# Staged-only interactive split
/doh-sys:commit --split --staged-focused --interactive

# Combine with existing options
/doh-sys:commit --split --no-lint --staged-focused
```

### Smart Staging Analysis Algorithm

```bash
analyze_workspace_changes() {
    # Phase 1: Analyze current staging state
    staged_files=$(git diff --cached --name-only)
    unstaged_files=$(git diff --name-only)
    untracked_files=$(git ls-files --others --exclude-standard)
    
    echo "🔍 Workspace Analysis:"
    echo "├── Staged files: $(echo "$staged_files" | wc -l)"
    if [[ "$STAGED_FOCUSED" != "true" ]]; then
        echo "├── Modified unstaged: $(echo "$unstaged_files" | wc -l)" 
        echo "└── Untracked files: $(echo "$untracked_files" | wc -l)"
    else
        echo "└── Mode: Staged-focused (ignoring unstaged files)"
    fi
    
    # Phase 2: Process staged files (required)
    if [[ -n "$staged_files" ]]; then
        echo "📋 Processing staged files..."
        categorize_and_split_staged_files "$staged_files"
    else
        echo "❌ No staged files found. Use 'git add' to stage files first."
        exit 1
    fi
    
    # Phase 3: Handle remaining unstaged files (only if not staged-focused)
    if [[ "$STAGED_FOCUSED" != "true" ]]; then
        remaining_files=$(combine_remaining "$unstaged_files" "$untracked_files")
        if [[ -n "$remaining_files" ]]; then
            echo "📋 Remaining unstaged files available for inclusion..."
            offer_unstaged_inclusion "$remaining_files"
        fi
    else
        echo "🎯 Staged-focused mode: Processing only staged files"
    fi
}

categorize_and_split_staged_files() {
    local staged_files=$1
    
    # Smart categorization of already staged files
    epic_files=$(echo "$staged_files" | grep -E "todo/.*\.md|NEXT\.md")
    doh_system_files=$(echo "$staged_files" | grep -E "\.claude/doh/|\.claude/commands/")
    docs_files=$(echo "$staged_files" | grep -E "README\.md|WORKFLOW\.md|DEVELOPMENT\.md|CHANGELOG\.md")
    runtime_files=$(echo "$staged_files" | grep -E "\.claude/commands/doh/")
    
    # Create split plan from staged files only
    create_staged_split_plan "$epic_files" "$doh_system_files" "$docs_files" "$runtime_files"
}

offer_unstaged_inclusion() {
    local remaining_files=$1
    
    # First, auto-detect obvious semantic matches
    obvious_matches=$(detect_obvious_semantic_matches "$remaining_files")
    
    if [[ -n "$obvious_matches" ]]; then
        echo "🎯 Auto-staging obvious semantic matches:"
        echo "$obvious_matches" | while read -r file; do
            category=$(categorize_single_file "$file")
            echo "  ✅ $file ($category) - obvious match"
            git add "$file"
        done
        echo ""
    fi
    
    # Then handle remaining files
    remaining_after_obvious=$(exclude_files "$remaining_files" "$obvious_matches")
    
    if [[ -n "$remaining_after_obvious" ]]; then
        echo "📂 Additional unstaged files available:"
        echo "$remaining_after_obvious" | while read -r file; do
            category=$(categorize_single_file "$file")
            echo "  • $file ($category)"
        done
        
        echo ""
        echo "Include additional unstaged files? [Y/n/select]"
        read -r response
        
        case $response in
            "select")
                interactive_file_selection "$remaining_after_obvious"
                ;;
            "n")
                echo "Using staged + auto-staged files (focused approach)..."
                ;;
            *)
                auto_include_relevant_unstaged "$remaining_after_obvious"
                ;;
        esac
    fi
}

detect_obvious_semantic_matches() {
    local unstaged_files=$1
    local obvious_matches=""
    
    # Rule 1: If todo/NEXT.md is staged and todo/T###.md is unstaged → obvious match
    if git diff --cached --name-only | grep -q "todo/NEXT.md"; then
        new_task_files=$(echo "$unstaged_files" | grep -E "todo/T[0-9]+\.md$")
        obvious_matches="$obvious_matches\n$new_task_files"
    fi
    
    # Rule 2: If .claude/commands/doh-sys/commit.md is staged and .claude/commands/doh/*.md modified → potential match
    if git diff --cached --name-only | grep -q "\.claude/commands/doh-sys/"; then
        doh_runtime_commands=$(echo "$unstaged_files" | grep -E "\.claude/commands/doh/.*\.md$")
        # Only auto-add if it's clear enhancement (e.g., same feature being added to both systems)
        obvious_matches="$obvious_matches\n$doh_runtime_commands"
    fi
    
    # Rule 3: If epic/task documentation is staged and related implementation exists
    staged_tasks=$(git diff --cached --name-only | grep -E "todo/T[0-9]+\.md$" | sed 's/todo\/T\([0-9]*\)\.md/T\1/')
    for task in $staged_tasks; do
        # Look for related implementation files
        related_impl=$(echo "$unstaged_files" | grep -E "\.(md|sh|js)$" | xargs grep -l "$task" 2>/dev/null)
        if [[ -n "$related_impl" ]]; then
            obvious_matches="$obvious_matches\n$related_impl"
        fi
    done
    
    # Rule 4: Documentation sets - if README.md staged and DEVELOPMENT.md/WORKFLOW.md modified
    if git diff --cached --name-only | grep -q -E "(README|DEVELOPMENT|WORKFLOW)\.md"; then
        doc_set=$(echo "$unstaged_files" | grep -E "(README|DEVELOPMENT|WORKFLOW|CHANGELOG)\.md$")
        obvious_matches="$obvious_matches\n$doc_set"
    fi
    
    # Clean up and return unique matches
    echo -e "$obvious_matches" | grep -v "^$" | sort -u
}

create_commit_sequence() {
    # Priority order: Epic → System → Docs → Implementation → Misc
    if [[ -n "$epic_files" ]]; then
        plan_epic_commit "$epic_files"
    fi
    
    if [[ -n "$doh_system_files" ]]; then
        plan_system_commit "$doh_system_files"
    fi
    
    # Continue iteratively with remaining categories
}
```

### Smart Message Generation

```bash
generate_commit_message() {
    local category=$1
    local files=$2
    
    case $category in
        "epic")
            local completed_tasks=$(extract_completed_tasks "$files")
            echo "feat: Complete $completed_tasks and update project roadmap"
            ;;
        "doh_system")
            local component=$(detect_doh_component "$files")
            local improvement=$(analyze_system_changes "$files")
            echo "feat: Enhance DOH $component with $improvement"
            ;;
        "documentation")
            local doc_focus=$(analyze_doc_changes "$files")
            echo "docs: Update project documentation - $doc_focus"
            ;;
        *)
            generate_default_message "$category" "$files"
            ;;
    esac
}
```

### Safety & Preview Features

```bash
preview_split_plan() {
    echo "🔍 Proposed Commit Split:"
    echo ""
    
    for i in "${!planned_commits[@]}"; do
        echo "Commit $((i+1)): ${commit_messages[i]}"
        echo "  Files: ${commit_files[i]}"
        echo "  Changes: ${change_summaries[i]}"
        echo ""
    done
    
    echo "Execute this plan? [Y/n/preview-diff]"
}

execute_split_commits() {
    for i in "${!planned_commits[@]}"; do
        echo "Creating commit $((i+1))/${#planned_commits[@]}: ${commit_messages[i]}"
        
        # Stage only files for this commit
        git reset HEAD >/dev/null
        git add ${commit_files[i]}
        
        # Create commit with generated message
        git commit -m "${commit_messages[i]}"
        
        echo "✅ Commit $((i+1)) complete"
    done
}
```

## User Experience Scenarios

### Scenario 1: Smart Semantic Matching

```bash
# User has staged some files manually
$ git add todo/T064.md todo/NEXT.md

# Algorithm detects semantic relationships
$ /doh-sys:commit --split

🔍 Workspace Analysis:
├── Staged files: 2
├── Modified unstaged: 15
└── Untracked files: 3

📋 Processing staged files...
🎯 Auto-staging obvious semantic matches:
  ✅ .claude/commands/doh-sys/commit.md (doh-system) - obvious match
  ✅ .claude/doh/templates/memory_structure.md (doh-system) - obvious match

📂 Additional unstaged files available:
  • .claude/commands/doh/next.md (runtime-commands)
  • DEVELOPMENT.md (documentation)

Include additional unstaged files? [Y/n/select]
> n

🚀 Executing Split Sequence:
├── ✅ Commit 1/2: feat: Complete T064 commit splitting and update roadmap
│   └── Files: todo/T064.md, todo/NEXT.md
└── ✅ Commit 2/2: feat: Enhance DOH commit pipeline with semantic splitting
    └── Files: .claude/commands/doh-sys/commit.md, .claude/doh/templates/

🎉 Split complete! Created 2 focused commits (2 auto-staged)
```

### Scenario 2: Large Epic Completion

```bash
$ /doh-sys:commit --split --dry-run

🔍 Analysis: 15 files staged across 4 semantic categories

📋 Proposed Commit Sequence:

Commit 1: "feat: Complete T059 AI Task Engine and update project roadmap"
  Files: todo/T059.md, todo/NEXT.md, todo/T061.md
  Changes: Task completion status, memory updates, dependency graph

Commit 2: "feat: Enhance DOH runtime with AI task intelligence system"  
  Files: .claude/commands/doh/next.md, .claude/doh/templates/memory_structure.md
  Changes: New /doh:next command, memory architecture templates

Commit 3: "docs: Update DOH runtime documentation with task intelligence"
  Files: .claude/doh/inclaude.md
  Changes: Added task intelligence section, pipeline automation docs

Execute this 3-commit sequence? [Y/n/edit-messages]
```

### Scenario 2: Mixed Development Changes

```bash
$ /doh-sys:commit --split --interactive

🔍 Analysis: 8 files staged across 3 semantic categories

Commit 1/3: "feat: Complete T032 build system design"
Files: todo/T032.md, todo/NEXT.md
Execute this commit? [Y/n/edit/skip]: Y
✅ Commit 1 complete

Commit 2/3: "feat: Implement runtime build process"
Files: .claude/doh/scripts/build-runtime.sh, .claude/doh/scripts/lib/build-utils.sh
Execute this commit? [Y/n/edit/skip]: n

Edit commit message: feat: Add DOH runtime build automation scripts
✅ Commit 2 complete

Commit 3/3: "docs: Update build documentation"
Files: DEVELOPMENT.md
Execute this commit? [Y/n/edit/skip]: Y
✅ Commit 3 complete

Split complete! Created 3 focused commits.
```

## Success Criteria

- [ ] **Semantic analysis** correctly categorizes staged changes by logical grouping
- [ ] **Epic/TODO priority** - Heavy planning updates always committed first
- [ ] **Intelligent splitting** creates focused, single-purpose commits
- [ ] **Smart messages** generate contextually appropriate commit descriptions
- [ ] **Preview functionality** allows review before execution
- [ ] **Safety features** enable rollback and manual override when needed

## Benefits & Impact

- **Cleaner History**: Semantic commits create readable, traceable project timeline
- **Better Traceability**: Each commit focuses on single logical unit of work
- **Epic Completion Clarity**: TODO/epic updates are isolated and clearly marked
- **Automated Intelligence**: Reduces mental overhead of commit organization
- **Development Flow**: Maintains development momentum while improving commit quality

## Integration Points

- **Extends**: Current `/doh-sys:commit` functionality with non-breaking enhancement
- **Integrates with**: `/doh-sys:lint`, `/doh-sys:changelog` pipeline commands
- **Complements**: T059 task intelligence system for epic-aware commit planning
- **Prepares for**: Advanced git workflow automation in future versions

## Implementation Notes

**Backward Compatibility**: `--split` is optional flag - existing behavior unchanged for standard usage.

**Strategy Priority**: Epic/TODO updates first ensures project management changes are committed before implementation details.

**Content Analysis**: Smart message generation analyzes actual file changes, not just filenames, for accurate commit descriptions.

**Safety First**: Preview and confirmation modes prevent unwanted automated commits while providing intelligent defaults.

## Deliverable

Enhanced `/doh-sys:commit` command with `--split` flag that intelligently analyzes staging area and creates semantically focused multiple commits, prioritizing epic/TODO updates first and iteratively processing remaining changes to produce clean, traceable commit history that tells the story of development progress.

This enhancement transforms large, unfocused commits into logical sequences that improve project traceability while maintaining development workflow efficiency through intelligent automation.

---