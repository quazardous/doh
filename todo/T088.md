# T088 - Comprehensive Auto-Correcting Linting System

**Status**: ACTIVE  
**Priority**: HIGH  
**Dependencies**: None  
**Epic**: None

Implement a comprehensive auto-correcting linting system combining Prettier, markdownlint-cli with --fix, and codespell with -w to achieve near 100% automatic formatting and correction for Markdown files.

## Current Problems

1. **No single-file support**: /dd:lint operates on entire project, not specific files
2. **Inefficient for spot-checking**: Commands like /dd:commit need to lint individual files
3. **No programmatic interface**: Other commands can't easily call /dd:lint for specific files
4. **All-or-nothing approach**: Can't fix one file at a time during development workflows

## Proposed Solutions (Brainstorm)

### **Option A: File-Specific /dd:lint Enhancement**
```bash
/dd:lint [file-path]                    # Lint single file
/dd:lint [file-path] --fix              # Auto-fix single file  
/dd:lint [glob-pattern]                 # Lint matching files
/dd:lint --all                          # Current behavior (entire project)
```

**Benefits**: 
- ‚úÖ Simple extension of existing command
- ‚úÖ Backward compatible with --all flag
- ‚úÖ Clear interface for other commands

**Concerns**:
- ‚ö†Ô∏è Need to ensure 100% reliability for single files
- ‚ö†Ô∏è Error handling for non-existent files

### **Option B: Dedicated Single-File Linting Script**
```bash
.claude/doh/scripts/lint-file.sh [file-path] [--fix]
```

**Benefits**:
- ‚úÖ Focused, lightweight utility
- ‚úÖ Easy to call from other commands
- ‚úÖ No risk of breaking existing /dd:lint behavior

**Concerns**:
- ‚ùå Additional script to maintain
- ‚ùå Not accessible via /dd: command interface

### **Option C: Hybrid Approach - Enhanced /dd:lint + Utility Script**
- **Enhanced /dd:lint**: File-specific interface for users
- **Backend script**: `.claude/doh/scripts/lint-single.sh` for internal command usage
- **Shared logic**: Both use same underlying linting tools

### **Option D: Linting Service Architecture**
```bash
/dd:lint-service start                  # Background linting daemon
/dd:lint-service check [file]           # Check specific file
/dd:lint-service fix [file]             # Fix specific file  
/dd:lint-service stop                   # Stop daemon
```

**Benefits**:
- ‚úÖ Maximum efficiency (no startup overhead)
- ‚úÖ Advanced caching and incremental checking

**Concerns**:
- ‚ùå Over-engineering for current needs
- ‚ùå Complex state management

## **DECISIONS CONFIRM√âES**

- ‚ùå **Pas de caching** : Simplicit√© > optimisation pr√©matur√©e
- ‚úÖ **Config projet** : Utilise config existante des outils (markdownlint.json, etc.)
- üìã **Parall√©lisation** : Oui mais pas priorit√© initiale
- üîß **Linters disponibles** : markdownlint, shellcheck, eslint, prettier uniquement
- ü§ñ **Fallback Claude** : Si linters √©chouent ‚Üí Claude corrige

## Recommended Implementation: **Option A + Backend Script**

### **Phase 1: Backend Script**
Create `.claude/doh/scripts/lint-single-file.sh`:

```bash
#!/bin/bash
# Usage: lint-single-file.sh <file-path> [--check-only]
#
# DEFAULT: Auto-fix issues and report remaining errors on stdout
# --check-only: Only check, no fixes applied
#
# Config: Uses existing project config (markdownlint.json, .eslintrc, etc.)
# Fallback: If linters fail, Claude AI handles corrections
# 
# Return codes:
#   0 = Clean (no issues)  
#   1 = Issues found/fixed (check stdout for details)
#   2 = Fatal error (file not found, etc.)

file_path="$1"
check_only="$2"

# Validation
if [[ ! -f "$file_path" ]]; then
    echo "‚ùå Error: File not found: $file_path" >&2
    exit 2
fi

# Exit code tracking
exit_code=0

# Fix-first approach (default behavior)
fix_mode="yes"
if [[ "$check_only" == "--check-only" ]]; then
    fix_mode="no"
fi

echo "üîç Processing: $file_path"

# Determine file type and apply appropriate linting
case "$file_path" in
    *.md)
        if [[ "$fix_mode" == "yes" ]]; then
            # Fix first, then check for remaining issues
            markdownlint --fix "$file_path" 2>/dev/null || true
            prettier --write "$file_path" 2>/dev/null || true
            # Check for remaining issues
            if ! markdownlint "$file_path" 2>&1; then
                exit_code=1
            fi
        else
            # Check only mode
            markdownlint "$file_path" || exit_code=1
        fi
        ;;
    *.sh)
        # shellcheck has no --fix, always check-only
        shellcheck "$file_path" || exit_code=1
        if [[ $exit_code -ne 0 && "$fix_mode" == "yes" ]]; then
            echo "ü§ñ shellcheck issues detected - Claude AI intervention needed"
        fi
        ;;
    *.js|*.ts)
        if [[ "$fix_mode" == "yes" ]]; then
            prettier --write "$file_path" 2>/dev/null || true
            eslint --fix "$file_path" 2>/dev/null || true
            # Check for remaining issues
            if ! eslint "$file_path" 2>&1; then
                exit_code=1
            fi
        else
            eslint "$file_path" || exit_code=1
        fi
        ;;
    *.json)
        if [[ "$fix_mode" == "yes" ]]; then
            prettier --write "$file_path" 2>/dev/null || true
        fi
        # Always validate JSON syntax
        if ! node -e "JSON.parse(require('fs').readFileSync('$file_path'))" 2>&1; then
            exit_code=1
        fi
        ;;
    *)
        if [[ "$fix_mode" == "yes" ]]; then
            prettier --write "$file_path" 2>/dev/null || true
        fi
        echo "‚ÑπÔ∏è  Generic file - limited linting available"
        ;;
esac

# Report final status
if [[ $exit_code -eq 0 ]]; then
    echo "‚úÖ Clean: $file_path"
else
    echo "‚ùå Issues remain after auto-fix: $file_path"
    if [[ "$fix_mode" == "yes" ]]; then
        echo "ü§ñ Claude AI intervention may be needed for remaining issues"
    fi
fi

exit $exit_code
```

### **Phase 2: Enhanced /dd:lint Command**

Add to existing /dd:lint command:

```bash
# Usage patterns:
/dd:lint                                # Current behavior (all files)
/dd:lint todo/T088.md                   # Fix + lint single file (default)
/dd:lint todo/T088.md --check-only      # Check single file (no fixes)
/dd:lint "*.md"                         # Fix + lint glob pattern  
/dd:lint --file todo/T088.md            # Explicit file flag (with fixes)
```

### **Phase 3: Integration Points**

Enable other commands to use the linting:

```bash
# From /dd:commit T087 STRICT enforcement:
if ! .claude/doh/scripts/lint-single-file.sh "$staged_file"; then
    echo "‚ùå LINTING FAILED - COMMIT BLOCKED"
    echo "Fix issues or use --force to override"
    exit 1
fi

# From /dd:changelog when editing TODO files:
.claude/doh/scripts/lint-single-file.sh todo/T088.md  # Auto-fixes by default

# From Claude AI when linter tools fail:
# Claude reads file, applies corrections, writes back
# Then validates with: lint-single-file.sh "$file" (should return 0)
```

## Success Criteria

- ‚úÖ **Single-file linting**: `/dd:lint [file]` works reliably
- ‚úÖ **Auto-fix capability**: `--fix` flag repairs issues automatically  
- ‚úÖ **100% efficiency**: No false positives, handles all edge cases
- ‚úÖ **Integration ready**: Other commands can call for linting sub-tasks
- ‚úÖ **Error handling**: Clear error messages for missing files, syntax errors
- ‚úÖ **Performance**: Fast execution for single files (< 1 second)
- ‚úÖ **File type detection**: Automatic tool selection based on file extension
- ‚úÖ **Return codes**: Programmatic success/failure indication

## Implementation Tasks

- [ ] Create `.claude/doh/scripts/lint-single-file.sh` backend script
- [ ] Enhance `/dd:lint` command to accept file arguments  
- [ ] Add file type detection and appropriate tool routing
- [ ] Implement --fix mode for automatic repairs
- [ ] Add comprehensive error handling and validation
- [ ] Test with various file types (markdown, shell, JSON, etc.)
- [ ] Integration testing with /dd:commit T087 behavior
- [ ] Performance benchmarking for single-file operations
- [ ] Documentation updates for new usage patterns

**Deliverable**: Reliable, efficient single-file linting utility that serves as foundation for T087 STRICT enforcement architecture.