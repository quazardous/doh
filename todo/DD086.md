# DD086 - Add --unstaged flag for Pass 2 only processing

**Status**: PROPOSED - NOT SURE  
**Priority**: LOW - Nice to have feature  
**Dependencies**: DD085 (2-pass algorithm implementation)  
**Epic**: None  
**Tags**: `#feature-request` `#staging-flags` `#pass2-only` `#not-sure`  
**Created**: 2025-08-28

## üìã Problem Statement

**Potential Use Case**: Allow developers to process only unstaged files (Pass 2) without touching staged files.

### Hypothetical Scenario

```bash
# Developer has carefully staged some files for later
# But wants to commit unstaged modifications first

git add important-feature.js tests/important-feature.test.js  # Staged for later
# Modified: docs/README.md, package.json, config.json         # Want to commit now

/dd:commit --split --unstaged "cleanup before feature"
# ‚Üí Only process unstaged files
# ‚Üí Leave staged files for dedicated feature commit later
```

## ü§î Technical Challenges

### Staging Area Manipulation Required

```bash
# Current state:
# STAGED: important-feature.js, tests/important-feature.test.js
# UNSTAGED: docs/README.md, package.json, config.json

# To process only unstaged files:
1. Save current staging state
2. Reset staging area
3. Stage only the unstaged files we want to process
4. Process with Pass 2 algorithm
5. Restore original staging state for the staged files
```

### Complex State Management

- **Staging backup/restore**: Need to preserve original staging intentions
- **Selective staging**: Stage only specific unstaged files for processing
- **Error recovery**: If something fails, restore exact original state
- **Performance impact**: Additional git operations for state management

## üéØ Proposed Implementation (If Decided)

### Phase 1: Staging State Management

```javascript
const processUnstagedOnly = async () => {
  // 1. Backup current staging state
  const originalStaging = await getCurrentStagingState();

  try {
    // 2. Get unstaged files for processing
    const unstagedFiles = await getUnstagedFiles();

    // 3. Reset staging area
    await resetStaging();

    // 4. Process unstaged files with Pass 2 algorithm
    let remainingFiles = unstagedFiles;
    while (remainingFiles.length > 0) {
      const group = findNextLogicalGroup(remainingFiles);
      await stageFiles(group);
      await createCommit(generateGroupMessage(group));
      remainingFiles = remainingFiles.filter((f) => !group.includes(f));
    }
  } finally {
    // 5. Restore original staging state
    await restoreStagingState(originalStaging);
  }
};
```

### Phase 2: Integration with Existing Modes

```bash
# New flag behavior
/dd:commit --split --unstaged "cleanup docs and config"

# Behavior:
# 1. Skip Pass 1: Ignore staged files completely
# 2. Pass 2 Only: Process unstaged files with iterative algorithm
# 3. Restore staging: Staged files remain staged as originally intended
```

## ‚ö†Ô∏è Concerns & Questions

### Use Case Validation

- **Is this actually needed?** How often would developers want this?
- **Alternative approaches**: Could developers just `git stash` the staged files instead?
- **Workflow complexity**: Does this add unnecessary complexity to the interface?

### Technical Complexity vs Benefit

- **High implementation cost**: Staging state management is complex and error-prone
- **Low usage frequency**: Likely edge case scenario
- **Maintenance overhead**: Additional code paths to test and maintain
- **Error scenarios**: What if staging restore fails?

### Alternative Solutions

```bash
# Instead of --unstaged flag, developers could:

# Option 1: Stash staged files temporarily
git stash push --staged -m "feature work in progress"
/dd:commit --split "cleanup docs and config"
git stash pop

# Option 2: Use --staged first, then normal processing
/dd:commit --split --staged "complete feature work"
/dd:commit --split "cleanup remaining files"

# Option 3: Manual selective staging
git add docs/README.md package.json config.json
/dd:commit --split "cleanup docs and config"
# (staged files remain for later)
```

## ü§∑ Recommendation: NOT SURE

### Arguments FOR Implementation

- ‚úÖ **Workflow flexibility**: Provides maximum control over staging/unstaging
- ‚úÖ **Completeness**: Rounds out the flag set (--staged, --staged-only, --unstaged)
- ‚úÖ **Edge case coverage**: Handles specific workflow scenarios

### Arguments AGAINST Implementation

- ‚ùå **High complexity**: Staging state management is complex and risky
- ‚ùå **Low utility**: Alternative approaches exist and may be simpler
- ‚ùå **Maintenance cost**: Additional code paths and error scenarios
- ‚ùå **User confusion**: More flags can make interface more complex

## üí≠ Decision Criteria

**Implement IF**:

- [ ] Clear user demand emerges through actual usage
- [ ] Alternative approaches prove insufficient for real workflows
- [ ] Staging state management can be implemented robustly
- [ ] Benefits clearly outweigh implementation complexity

**Skip IF**:

- [ ] Alternative approaches handle the use cases adequately
- [ ] Implementation complexity is too high relative to benefit
- [ ] No clear user demand for this specific workflow
- [ ] Interface simplicity is prioritized over completeness

## üìã Implementation Tasks (If Decided)

### Core Implementation

- [ ] Implement staging state backup/restore utilities
- [ ] Create --unstaged flag processing logic
- [ ] Integrate with Pass 2 iterative algorithm
- [ ] Add error recovery for staging operations

### Testing & Validation

- [ ] Test staging state preservation across various scenarios
- [ ] Validate error recovery when operations fail
- [ ] Performance testing with large staging areas
- [ ] User workflow testing for real-world scenarios

### Documentation & Integration

- [ ] Update command documentation with --unstaged flag
- [ ] Add usage examples and workflow guidance
- [ ] Update help system and flag compatibility matrix
- [ ] Integration testing with existing staging modes

## Estimated Effort (If Implemented)

**Total**: 3-4 hours

- Staging State Management: 2 hours
- Integration & Testing: 1-2 hours

**Risk**: High - Staging manipulation is complex and error-prone

---

**Status**: Marked as "NOT SURE" - needs validation of actual use cases and cost/benefit analysis before proceeding with
implementation.
