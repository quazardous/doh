# T085 - Implement intelligent 2-pass staging algorithm for /dd:commit --split

**Status**: COMPLETED (2025-08-28)  
**Priority**: HIGH - Critical staging logic improvement  
**Dependencies**: T084 (staging management foundation)  
**Epic**: None  
**Tags**: `#algorithm-improvement` `#staging-optimization` `#developer-intent` `#workflow`  
**Created**: 2025-08-28  

## ðŸ“‹ Problem Statement

**Current Algorithm is Sub-Optimal**: The current T084 implementation has a fundamental flaw in its "Clean Working Directory" approach:

### Current Problematic Flow
```bash
# Current T084 behavior:
git add -A                    # âŒ Stage EVERYTHING first
# â†’ Lost developer's staging intention
# â†’ Need complex logic to "un-stage" and re-group
# â†’ Sub-optimal commit organization
```

### Core Issues

1. **Lost Developer Intent**: `git add -A` destroys the developer's intentional staging choices
2. **Sub-Optimal Grouping**: Having to "undo" staging to create logical groups is backward
3. **Complex Logic**: Current approach requires complex staging/unstaging juggling
4. **Poor Performance**: Multiple staging operations instead of intelligent analysis

## ðŸŽ¯ Solution: Intelligent 2-Pass Algorithm

### **Pass 1: Process Staged Files (Priority Intent)**
- **Respect staging intention**: Developer staged files for a reason
- **Iterative commit creation**: Find logical groups in staged files, commit each group
- **Smart extension**: Can add related unstaged files to complete logical groups
- **Progressive processing**: Stage â†’ analyze â†’ group â†’ commit â†’ repeat

### **Pass 2: Process Remaining Unstaged Files**  
- **Clean remaining modifications**: Handle unstaged files after staged intent is honored
- **Semantic grouping**: Apply same intelligent grouping to remaining files
- **Complete cleanup**: Still achieve clean working directory goal

## ðŸ”„ Enhanced Algorithm Design

### Phase 1: Staged Files Processing (Respects Developer Intent)

```javascript
const processStagedFiles = async () => {
  let remainingStagedFiles = await getStagedFiles();
  const commits = [];
  
  while (remainingStagedFiles.length > 0) {
    // Find next logical group from staged files
    const logicalGroup = findNextLogicalGroup(remainingStagedFiles);
    
    // Smart extension: add related unstaged files if they complete the group
    const relatedUnstaged = findRelatedUnstagedFiles(logicalGroup);
    const fullGroup = [...logicalGroup, ...relatedUnstaged];
    
    // Create focused commit
    await resetStaging();
    await stageFiles(fullGroup);
    const commitHash = await createCommit(generateGroupMessage(fullGroup));
    commits.push(commitHash);
    
    // Remove processed files from remaining
    remainingStagedFiles = remainingStagedFiles.filter(f => !logicalGroup.includes(f));
  }
  
  return commits;
};
```

### Phase 2: Unstaged Files Processing (Iterative Clean Remaining)

```javascript  
const processUnstagedFiles = async () => {
  let remainingUnstagedFiles = await getUnstagedFiles();
  const commits = [];
  
  // Same iterative approach as Pass 1
  while (remainingUnstagedFiles.length > 0) {
    // Find next logical group from remaining unstaged files
    const logicalGroup = findNextLogicalGroup(remainingUnstagedFiles);
    
    // Create focused commit  
    await resetStaging();
    await stageFiles(logicalGroup);
    const commitHash = await createCommit(generateGroupMessage(logicalGroup));
    commits.push(commitHash);
    
    // Remove processed files from remaining
    remainingUnstagedFiles = remainingUnstagedFiles.filter(f => !logicalGroup.includes(f));
  }
  
  return commits;
};
```

## ðŸ’¡ Intelligent Grouping Logic

### Priority-Based Group Detection

**For Staged Files (Pass 1)**:
1. **Epic/TODO completions**: `todo/*.md` with COMPLETED status
2. **Feature implementations**: Related source + test + doc files  
3. **Command enhancements**: `.claude/commands/` + related documentation
4. **Documentation updates**: Standalone doc improvements
5. **Configuration changes**: Build, package, config modifications

**Smart Extension Rules**:
- **Test files**: If `src/feature.js` staged, consider `tests/feature.test.js`
- **Documentation**: If command staged, consider related README sections  
- **Configuration**: If package.json staged, consider related config files
- **Same directory**: Files in same directory as staged files

### Example 2-Pass Workflow

```bash
# Developer has intentionally staged:
# STAGED: todo/T085.md, .claude/commands/dd/commit.md  
# UNSTAGED: README.md, tests/commit.test.js, package.json, src/utils.js

# PASS 1: Honor staging intent
Commit 1: "feat: Complete T085 staging algorithm improvement"
  Files: todo/T085.md (developer's priority)

Commit 2: "feat: Enhance /dd:commit with 2-pass staging algorithm"  
  Files: .claude/commands/dd/commit.md + tests/commit.test.js (smart extension)
  
# PASS 2: Iterative processing of remaining unstaged files
Commit 3: "docs: Update project documentation"
  Files: README.md (next logical group)
  
Commit 4: "chore: Update dependencies and utilities"  
  Files: package.json, src/utils.js (next logical group)
```

## ðŸŽ¯ Simplified Mode Behaviors

### Default Mode: "Complete 2-Pass Processing"
```bash
/dd:commit --split "T085 implementation"

# Behavior:
# 1. Pass 1: Process staged files with smart extensions
# 2. Pass 2: Process remaining unstaged files iteratively  
# 3. Result: Clean directory + respected developer intent
```

### --staged: "Pass 1 Only" (Renamed from --staged-focused)
```bash
/dd:commit --split --staged "staged work only"

# Behavior:
# 1. Pass 1: Process staged files with smart extensions
# 2. No Pass 2: Stop after staged files are processed
# 3. Result: Staged intent honored, unstaged files remain
```

### --staged-only: "Pass 1 Without Extensions" (Conservative)
```bash
/dd:commit --split --staged-only "strict staged only"

# Behavior:
# 1. Pass 1: Process ONLY staged files, no smart extensions
# 2. No Pass 2: Ignore unstaged files completely
# 3. Result: Most conservative staged-only processing
```

## ðŸ”§ Implementation Strategy

### Phase 1: Core 2-Pass Algorithm (2h)

#### A. Pass 1 Implementation
- [ ] **Staged file analysis**: Detect logical groups within staged files
- [ ] **Smart extension detection**: Find related unstaged files per group
- [ ] **Iterative commit creation**: Process staged files group by group
- [ ] **Intent preservation**: Never mass-stage, always respect original staging

#### B. Pass 2 Implementation (Iterative)
- [ ] **Remaining file detection**: Identify all unstaged modifications after Pass 1
- [ ] **Iterative grouping**: Same group â†’ commit â†’ repeat approach as Pass 1
- [ ] **Logical group detection**: Find next logical group from remaining files  
- [ ] **Progressive cleanup**: Process unstaged files group by group until complete

### Phase 2: Enhanced Smart Extension (1.5h)

#### A. Relationship Analysis
- [ ] **Test file detection**: `tests/*.test.js` related to `src/*.js`
- [ ] **Documentation relationships**: README sections related to features
- [ ] **Configuration dependencies**: Config files related to implementations
- [ ] **Directory relationships**: Files in same logical directory

#### B. Extension Decision Logic
- [ ] **Conservative extension**: Only obvious relationships in --staged-focused
- [ ] **Intelligent extension**: Broader relationships in default mode  
- [ ] **User confirmation**: Option to confirm extensions in interactive mode
- [ ] **Extension logging**: Clear logging of why files were added to groups

### Phase 3: Mode Refinement (1h)

#### A. Mode-Specific Behaviors
- [ ] **Default mode**: Balanced 2-pass with smart extensions
- [ ] **--staged-focused mode**: Conservative extensions, maximum staged priority
- [ ] **Interactive integration**: Show extension decisions in interactive mode
- [ ] **Dry-run enhancement**: Preview 2-pass strategy clearly

#### B. Performance & UX
- [ ] **Progress indication**: Show Pass 1 vs Pass 2 progress
- [ ] **Clear messaging**: Explain why files are grouped together
- [ ] **Rollback capability**: Easy rollback if grouping is wrong
- [ ] **Extension controls**: Fine-tune extension aggressiveness

## ðŸ“Š Benefits of 2-Pass Algorithm

### Developer Experience
- âœ… **Respects intent**: Staged files get priority treatment as intended
- âœ… **Logical progression**: Staged work committed first, then cleanup
- âœ… **No staging loss**: Never destroys developer's careful staging choices
- âœ… **Predictable behavior**: Clear 2-pass logic that developers can understand

### Technical Benefits  
- âœ… **Performance**: No mass staging/unstaging juggling
- âœ… **Cleaner logic**: Straightforward 2-pass approach vs complex undo logic
- âœ… **Better grouping**: Groups form naturally without staging conflicts
- âœ… **Extensible**: Easy to add new relationship detection logic

### Workflow Integration
- âœ… **Compatible with existing modes**: Enhances all staging modes
- âœ… **Interactive friendly**: Clear pass distinction in interactive mode
- âœ… **Dry-run clarity**: Easy to preview 2-pass strategy
- âœ… **Error handling**: Better error recovery with clear pass boundaries

## ðŸ’¼ Success Criteria

### Algorithm Correctness
- [ ] **Pass 1 completeness**: All staged files processed with proper grouping
- [ ] **Pass 2 coverage**: All remaining unstaged files properly handled  
- [ ] **Smart extensions**: Related files correctly identified and grouped
- [ ] **Clean result**: Working directory completely clean after both passes

### Developer Intent Preservation
- [ ] **Staging respect**: Original staging choices always honored
- [ ] **Priority processing**: Staged files processed before unstaged
- [ ] **Logical grouping**: Files grouped based on actual relationships
- [ ] **No forced staging**: Never use `git add -A` style mass operations

### Performance & Experience
- [ ] **Efficient processing**: Minimal git operations, smart analysis
- [ ] **Clear communication**: Users understand why files are grouped  
- [ ] **Interactive control**: Full control in interactive mode
- [ ] **Error recovery**: Robust handling of edge cases

## Estimated Effort

**Total**: 4.5 hours
- Core 2-Pass Algorithm: 2 hours
- Enhanced Smart Extension: 1.5 hours  
- Mode Refinement: 1 hour

## Benefits & Impact

- **Developer Intent Preservation**: Respects careful staging choices
- **Optimal Performance**: No staging/unstaging juggling overhead
- **Cleaner Logic**: Straightforward 2-pass approach vs complex undo operations
- **Better User Experience**: Predictable, logical commit sequence
- **Professional Workflow**: Maintains staging best practices

This 2-pass algorithm addresses the fundamental flaw in T084's mass-staging approach and provides a much more intelligent, developer-respectful staging management system.

## âœ… Implementation Tasks

### Pass 1: Staged Files Processing
- [ ] Analyze currently staged files for logical grouping
- [ ] Implement smart extension detection for related unstaged files  
- [ ] Create iterative commit logic (group â†’ commit â†’ repeat)
- [ ] Preserve staging intention throughout process

### Pass 2: Unstaged Files Processing (Iterative)
- [ ] Detect remaining unstaged files after Pass 1  
- [ ] Implement same iterative approach: while(files) { group â†’ commit â†’ repeat }
- [ ] Progressive logical grouping of remaining modifications
- [ ] Ensure complete working directory cleanup through iteration

### Integration & Testing
- [ ] Update all staging modes to use 2-pass algorithm
- [ ] Enhance interactive mode to show pass distinction
- [ ] Update dry-run preview to show 2-pass strategy
- [ ] Test with various staging scenarios and file combinations